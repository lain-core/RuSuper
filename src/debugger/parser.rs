use crate::debugger::{
    utils::{HexOperators, HexToString},
    InvalidDbgArgError,
};

use crate::{emu::VirtualMachine, memory::MEMORY_END};

use super::parser_data::ParserData;

/**************************************** Struct and Type definitions ***************************************************/

/// Parseable tokens in debugger inputs.
#[derive(Clone, Debug, PartialEq, Eq)]

pub enum TokenSeparator {
    HexValue,
    Offset,
    Divider,       // Represents general divider character.
    Value(String), // Represents all numeric values (decimal and hex).
    Tag(String),   // Represents all non-value values (tag strings).
    Invalid,
}

impl From<&str> for TokenSeparator {
    fn from(value: &str) -> Self {
        match value {
            "$" => Self::HexValue,
            "+" => Self::Offset,
            " " => Self::Divider,
            _ => Self::Invalid,
        }
    }
}

pub type DebugTokenStream = Vec<TokenSeparator>;

/// Helper functions for the token streams generated by the parser.
pub trait TokenStreamHelpers {
    fn contains_tag(&self) -> bool;
    fn _modifies_tag(&self) -> bool;
    fn _next_tag(&self, start_index: usize) -> Option<usize>;
    fn get_tag_names(&self) -> Option<Vec<String>>;
}

impl TokenStreamHelpers for DebugTokenStream {
    /// Checks if there is a Tag(tagname) at any placement in the list.
    /// Parameters:
    ///     - `self`:   List of tokens
    /// Returns:
    ///     - `true`:   If the list contains a tag.
    ///     - `false`:  If the list does not contain a tag.
    fn contains_tag(&self) -> bool {
        for token in self {
            if let TokenSeparator::Tag(_value) = token {
                return true;
            }
        }
        false
    }

    /// Checks if there is an offset immediately applied to a tag at any point in the list.
    /// e.g. tagname + $XXX or $XXX + tagname
    /// Parameters:
    ///     - `self`: List of tokens
    /// Returns:
    ///     - `true`:   If there is an offset applied to a tag.
    ///     - `false`:  If there are no offsets applied directly to a tag.
    fn _modifies_tag(&self) -> bool {
        let mut last_token: Option<TokenSeparator> = None;
        for ref token in self {
            match token {
                TokenSeparator::Tag(_) => {
                    if let Some(TokenSeparator::Offset) = last_token {
                        return true;
                    }
                }
                TokenSeparator::Offset => {
                    if let Some(TokenSeparator::Tag(_)) = last_token {
                        return true;
                    }
                }
                _ => (),
            }
            last_token = Some((*token).clone());
        }
        false
    }

    /// Return the index of the next tag in the list.
    /// # Parameters:
    ///     - `self`:           List to parse
    ///     - `start_index`:    Where to begin parsing from to find tag.
    /// # Returns:
    ///     - `None`:           If no tags exist past this index.
    ///     - `Some(index)`:    The index of the next tag in the list.
    fn _next_tag(&self, start_index: usize) -> Option<usize> {
        for (index, token) in self[start_index..].iter().enumerate() {
            if let TokenSeparator::Tag(_) = token {
                return Some(index);
            }
        }
        None
    }

    /// Get a list of all of the tag names in the stream, if possible.
    /// # Parameters:
    ///     - `self`:       List to parse.
    /// # Returns:
    ///     - `Some(Vec<String>)`:  List of all of the tag names where possible,
    ///     - `None`:               If the list contained no tags.
    fn get_tag_names(&self) -> Option<Vec<String>> {
        let mut tags: Vec<String> = vec![];
        for token in self {
            if let TokenSeparator::Tag(name) = token {
                tags.push(name.clone());
            }
        }
        if !tags.is_empty() {
            Some(tags)
        } else {
            None
        }
    }
}

/**************************************** File Scope Functions **********************************************************/

/// Collect arguments from a set of strings input by the user.
/// # Parameters:
///     - `argvec`: List of arguments passed by the user to the function,
///     - `debug`:  Debugger state which contains the table of tags where needed.
/// # Returns:
///     - `Ok(DebugTokenStream)`:    Vector of tokens, where tags inside are represented as Value(tagname).
///     - `Err(InvalidDbgArgError)`:    Error if the user passed in an invalid argument.
fn collect_args(argvec: Vec<&str>) -> Result<DebugTokenStream, InvalidDbgArgError> {
    let mut delimiters: DebugTokenStream = vec![];
    let mut value_buffer: String = String::new();

    let args = argvec.join(" ");
    if !args.is_empty() {
        for current_char in args.chars() {
            let current_token = TokenSeparator::from(current_char.to_string().as_str());
            match current_token {
                // If a separator is found, clear the buffer of other characters and then push on the sepatator.
                TokenSeparator::HexValue | TokenSeparator::Offset => {
                    if !value_buffer.is_empty() {
                        delimiters.push(TokenSeparator::Value(value_buffer));
                        value_buffer = String::new();
                    }
                    delimiters.push(current_token);
                }

                // If we found a divider, just clear the buffer.
                TokenSeparator::Divider => {
                    if !value_buffer.is_empty() {
                        delimiters.push(TokenSeparator::Value(value_buffer));
                        value_buffer = String::new();
                    }
                }

                // If it is not a delimiting character, push it onto the value buffer for now.
                TokenSeparator::Invalid => {
                    value_buffer.push(current_char);
                }
                _ => (),
            }
        }
    } else {
        return Err(InvalidDbgArgError::from("Length of args passed was 0"));
    }
    // If there's anything left in the value buffer at the end throw it on.
    if !value_buffer.is_empty() {
        delimiters.push(TokenSeparator::Value(value_buffer));
    }
    Ok(delimiters)
}

/// Iterate through a vector of TokenSeparator, and for each TokenSeparator::Value, discern if it is a tag or a number.
/// A tag is any value which is not parseable as a decimal or hexadecimal value,
///     or a potential hexadecimal value which is not led by a TokenSeparator::HexValue.
/// # Parameters:
///     - `tokens`:         A list of tokens to digest, where all tags are represented as TokenSeparator::Value(tagname).
/// # Returns:
///     - `DebugTokenStream`: A vector of tokens, with TokenSeparator::Values, where all tags are represented as TokenSeparator::Tag(tagname).
fn collect_tags(tokens: DebugTokenStream) -> DebugTokenStream {
    let mut last_token: Option<TokenSeparator> = None;
    let mut new_vec: DebugTokenStream = vec![];

    for token in tokens {
        match token {
            TokenSeparator::Value(ref data) => {
                // If the value is strictly numeric, just push it on as a value.
                if data.is_decimal() {
                    new_vec.push(TokenSeparator::Value(data.to_string()));
                } else if data.is_hex() {
                    // If the value is in hex, check that the modifier was found to be present, or else we are looking at a tag name.
                    if let Some(TokenSeparator::HexValue) = last_token {
                        new_vec.push(TokenSeparator::Value(data.to_string()));
                    } else {
                        new_vec.push(TokenSeparator::Tag(data.to_string()));
                    }
                }
                // Otherwise put it on as a tag.
                else {
                    new_vec.push(TokenSeparator::Tag(data.to_string()));
                }
            }
            _ => new_vec.push(token.clone()),
        }
        last_token = Some(token);
    }

    new_vec
}

/// Parse a full list of arguments and check that if any tags within are being modified by an offset.
///     If they are, they must exist at the time we are checking, or else we have been handed a bad argument.
/// Parameters:
///     - `tokens`:     Mutable list of TokenSeparator tokens, where Tags are represented as Tag(tagname).
///     - `debug`:      Debugger with the list of tags to match from.
/// Returns:
///     - `Ok(Vec<TokenSeparator>)`:    A new list of tokens, with the tags represented as Value(*tagname) where possible, and any unknown tags at the tail.
///     - `Err(InvalidDbgArgError)`:    An error informing the user the first tag which is invalid.
fn deref_tags(
    mut tokens: DebugTokenStream, table: &ParserData,
) -> Result<DebugTokenStream, InvalidDbgArgError> {
    let mut last_token: Option<TokenSeparator> = None;
    let mut tag_as_value_stack: DebugTokenStream = vec![];

    // If the length of the stack coming in is just one, then shortcut the processing and just apply to it.
    // FIXME: This should probably be covered by the generalized case anyways. This might need some refactoring.
    if tokens.len() == 1 {
        if let Some(TokenSeparator::Tag(tagname)) = tokens.first() {
            // Try and deref.
            if let Some(value) = table.get_tag(tagname) {
                tag_as_value_stack.push(TokenSeparator::Value(value.to_hex_string()));
                tag_as_value_stack.push(TokenSeparator::HexValue);
            } else {
                tag_as_value_stack.push(TokenSeparator::Tag(tagname.to_string()));
            }
        }
    }
    // Push each of the values off of token onto the new tag_as_value_stack.
    else {
        while let Some(curr_token) = tokens.pop() {
            match curr_token {
                // When a tag is found, try to dereference it.
                TokenSeparator::Tag(ref tagname) => {
                    if let Some(value) = table.get_tag(tagname) {
                        // If it was dereferenced successfully, check if the last token was an offset, i.e.: TAG + VALUE.
                        // If it was, then this operation requires the literal value and so push the dereferenced value onto the stack.
                        if let Some(TokenSeparator::Offset) = last_token {
                            tag_as_value_stack
                                .push(TokenSeparator::Value((*value).to_hex_string()));
                            // All values stored in the hash map will be parsed coming out as hex.
                            tag_as_value_stack.push(TokenSeparator::HexValue);
                        }
                        // Otherwise check if the last token was a tag, and if so, then this can be pushed back on.
                        // If not, then this is the one we are trying to assign, and stick it at the front.
                        else if let Some(TokenSeparator::Tag(_)) = last_token {
                            tag_as_value_stack.push(TokenSeparator::Tag(tagname.clone()));
                        }
                        // Otherwise, this might be a tag value we're seeking to update.
                        else {
                            tag_as_value_stack.insert(0, TokenSeparator::Tag(tagname.clone()));
                        }
                    }
                    // If not, check if the last token was an Offset.
                    else {
                        // If it was, then print an error, because the user is trying to perform arithmetic with an undefined value.
                        if let Some(TokenSeparator::Offset) = last_token {
                            return Err(InvalidDbgArgError::from(format!("Attempting to perform arithmetic with a tag which is not yet defined: {}", tagname)));
                        }
                        // Otherwise, insert it to the front of the stack, so it will be at the end of our final list.
                        else {
                            tag_as_value_stack.insert(0, curr_token.clone());
                        }
                    }
                }

                // When an offset is found, check if the last item was a tag.
                TokenSeparator::Offset => {
                    // If it was, then try to deref it.
                    if let Some(TokenSeparator::Tag(tagname)) = last_token {
                        // If it can be dereferenced, push it on as a value with the offset, i.e.: VALUE + TAG.
                        if let Some(tag_value) = table.get_tag(&tagname) {
                            if let Some(TokenSeparator::Tag(_)) = tag_as_value_stack.last() {
                                tag_as_value_stack.pop();
                            }

                            tag_as_value_stack
                                .push(TokenSeparator::Value(tag_value.to_hex_string()));
                            tag_as_value_stack.push(TokenSeparator::HexValue);

                            tag_as_value_stack.push(TokenSeparator::Offset);
                        }
                        // If it can't be dereferenced, then print an error, because the user is trying to perform arithmetic with an undefined value.
                        else {
                            return Err(InvalidDbgArgError::from(format!("Attempting to perform arithmetic with a tag which is not yet defined: {}", tagname)));
                        }
                    }
                    // If it wasn't a tag, just push this on and proceed as normal.
                    else {
                        tag_as_value_stack.push(TokenSeparator::Offset);
                    }
                }

                // Any other operator doesn't have much bearing on our tag, so just leave them as they are.
                _ => {
                    tag_as_value_stack.push(curr_token.clone());
                }
            }
            last_token = Some(curr_token);
        }
    }

    // Reverse the stack back to the proper order.
    let mut result_tokens: DebugTokenStream = vec![];
    while let Some(token) = tag_as_value_stack.pop() {
        result_tokens.push(token);
    }

    Ok(result_tokens)
}

/// Take in a list of TokenSeparator, apply the modifiers to the values as desired, and spit out the resultant value.
/// # Parameters:
///     - `modifiers`:      List of TokenSeparator containing the modifiers to apply.
///     - `vm`:             Virtual Machine, in case the resultant value is an offset from the current PC.
///     - `base_addr`:      Base address to operate upon. If `None`, use the PC as the base address.
///     - `value`:          Target value to digest, either a tag or a numeric value.
/// # Returns:
///     - `Ok(value)`:                  The computed address value,
///     - `Err(InvalidDbgArgError)`:     If any of the arguments passed to this function were mangled.
fn apply_modifiers(
    modifiers: &mut DebugTokenStream, vm: &VirtualMachine, base_addr: Option<usize>, value: String,
) -> Result<usize, InvalidDbgArgError> {
    let mut scratch_value: usize = 0;
    if value.is_decimal() || value.is_hex() {
        // If the number is decimal go ahead and store the decimal representation into the scratch value.
        if value.is_decimal() {
            scratch_value = value.parse::<usize>().unwrap();
        }

        // Digest any modifiers found.
        if !modifiers.is_empty() {
            // Move right to left an apply the modifiers to the value.
            while let Some(ref modi) = modifiers.pop() {
                match *modi {
                    // If the value is a hex value, convert it to hex.
                    TokenSeparator::HexValue => {
                        scratch_value = value.to_hex()?;
                    }

                    // If there is an offset, do the math.
                    TokenSeparator::Offset => {
                        match base_addr {
                            // If there is some base address to operate on, add the scratch value to it.
                            Some(addr_value) => {
                                scratch_value += addr_value;
                            }
                            // If the address is none, the offset is relative to PC.
                            None => {
                                scratch_value += vm.cpu.get_pc();
                            }
                        }
                    }
                    _ => (),
                }
            }
        }
    }
    Ok(scratch_value)
}

/// Take a composed token list and compute a finalized address value.
/// Parameters:
///     - `args`: Arguments passed to the command, where tags are represented as Value(*tagname).
///     - `vm`:     Virtual machine to access memory or program counter from.
/// Returns:
///     - `Ok(address)`: A fully computed address.
///     - `Err(InvalidDbgArgError)`: If the tags in the stream failed to be dereferenced, or some other malformed data was found.
fn compute_address_from_args(
    args: &DebugTokenStream, table: &ParserData, vm: &VirtualMachine,
) -> Result<usize, InvalidDbgArgError> {
    let mut address: Option<usize> = None;
    let mut modifiers: Vec<TokenSeparator> = vec![];
    let mut last_value: Option<String> = None;
    let mut operator_found: bool = true;

    let mut deref_args = args.clone();
    // If a tag is in the stream passed, look to see if it is at the front or back.
    // If so, then it is a value we want to update.
    // If there are any left after the first, then error.
    if args.contains_tag() {
        match deref_tags(deref_args, table) {
            Ok(tokens) => {
                // If the tokens still contain a tag, check if it is length 1 (just tagname; to place at PC.) or not.
                if tokens.contains_tag() && tokens.len() > 1 {
                    return Err(InvalidDbgArgError::from(
                        "Value contained a tag which could not be dereferenced",
                    ));
                } else {
                    deref_args = tokens;
                }
            }
            Err(e) => return Err(e),
        }
    }

    // If the token is a value, apply the modifiers, then
    //      Check if there was an operator found between this and the last value. If not, raise an error.
    // If the token is a modifier, then mark that one was found and push it on.
    // Otherwise, just push it as it is onto the stack.
    for token in deref_args.iter() {
        match token {
            TokenSeparator::Value(data) => {
                match apply_modifiers(&mut modifiers, vm, address, data.to_string()) {
                    Ok(newaddr) => address = Some(newaddr),
                    Err(e) => return Err(e),
                }
                if !operator_found {
                    return Err(InvalidDbgArgError::from(format!(
                        "No operator found between {} and {}.",
                        last_value.expect(""),
                        data
                    )));
                }
                operator_found = false;
                last_value = Some(data.clone());
            }
            TokenSeparator::Offset => {
                operator_found = true;
                modifiers.push(token.clone());
            }
            _ => modifiers.push(token.clone()),
        }
    }

    match address {
        Some(val) => {
            // Lastly, check if the computed value is within memory bounds.
            if val < MEMORY_END {
                Ok(val)
            } else {
                Err(InvalidDbgArgError::from(format!(
                    "Final value {:#X} was out of memory bounds.",
                    val
                )))
            }
        }
        None => Err(InvalidDbgArgError::from(
            "Could not discern a value from arguments passed.",
        )),
    }
}

/**************************************** Public Functions **************************************************************/

/// Parse a list of directives out into a collection of tokens.
/// Parameters:
///     - `&args`:   The input from the user with the command removed and all other values concatenated.
/// Returns:
///     - `Ok(Vec<TokenSeparator>)`:   List of the arguments the user passed parsed into tokens.
///     - `Err(InvalidDbgArgError)`:   If any of the arguments given were invalid.
pub fn str_to_args(argvec: &[&str]) -> Result<DebugTokenStream, InvalidDbgArgError> {
    let mut arg_result: Result<DebugTokenStream, InvalidDbgArgError> =
        Err(InvalidDbgArgError::from("Invalid Arguments"));

    // First Pass: Convert the list of strings into a list of tokens as-is.
    if let Ok(delimiters) = collect_args(argvec.to_vec()) {
        // Second Pass: Convert all of the TokenSeparator::Value()s which correspond to tags into tags
        arg_result = Ok(collect_tags(delimiters));
    }

    arg_result
}

/// Take a stream, apply modifiers to the numeric values, and then create a tag.
/// # Parameters:
///     - `&input`:     Stream of tokens to parse, where tags have been deref'd where possible.
///     - `&table`:     `ParserData` type table of values to process.
///     - `&vm`:        `VirtualMachine` maintaining the state to use for obtaining the pc.
/// # Returns:
///     - `Ok(address)`:      Finalized address of the tag, for immediate use.
///     - `Err(InvalidDbgArgError)`: If any of the arguments passed in were incorrect.
pub fn create_new_tag(
    input: &DebugTokenStream, table: &ParserData, vm: &VirtualMachine,
) -> Result<(String, usize), InvalidDbgArgError> {
    let result: Result<(String, usize), InvalidDbgArgError>;

    match deref_tags(collect_tags(input.to_vec()), table) {
        Ok(mut tokens) => {
            let target_tag = tokens.pop();

            // If there was only one item in the stack then tackle the special case.
            if tokens.is_empty() {
                match target_tag {
                    // If the only thing returned is a single tag name, make a tag at the PC.
                    Some(TokenSeparator::Tag(ref tagname)) => {
                        result = Ok((tagname.to_string(), vm.cpu.get_pc()));
                    }
                    _ => result = Err(InvalidDbgArgError::from("Found no arguments in stream.")),
                }
            }
            // Otherwise proceed as normal.
            else {
                match target_tag {
                    Some(TokenSeparator::Tag(ref tagname)) => {
                        match compute_address_from_args(&tokens, table, vm) {
                            Ok(value) => {
                                result = Ok((tagname.to_string(), value));
                            }
                            Err(e) => {
                                result = Err(InvalidDbgArgError::from(format!(
                                    "{} Cannot create tag {}.",
                                    e, tagname
                                )));
                            }
                        }
                    }
                    _ => result = Err(InvalidDbgArgError::from("Found no arguments in stream.")),
                }
            }
        }
        Err(e) => {
            result = Err(e);
        }
    }
    result
}

/// Convert arguments as a vector of strings into a computed address value and any tags that match that value, where possible.
/// Note that this function will throw an error on any undigested TokenSeparator::Tag (i.e. any new tag).
/// # Parameters:
///     - `args`:       List of arguments to parse.
///     - `table`:      Pointer to table to read tags.
///     - `vm`:         Pointer to virtual machine, to fetch PC from.
/// # Result:
///     - `Ok(Option<Vec<String>>, usize)`: a pair of all the tags that match to value, and a computed address at value.
///     - `Err(InvalidDbgArgError)`:        Any error found while parsing.
pub fn str_to_values(
    args: &[&str], table: &ParserData, vm: &VirtualMachine,
) -> Result<(Option<Vec<String>>, usize), InvalidDbgArgError> {
    let token_args = str_to_args(args)?;
    let mut cmd_res: Result<(Option<Vec<String>>, usize), InvalidDbgArgError> =
        Err(InvalidDbgArgError::from("Unable to parse arguments"));
    let mut res_tags: Option<Vec<String>> = None;
    let mut res_value: Option<usize> = None;

    match compute_address_from_args(&token_args, table, vm) {
        Ok(value) => res_value = Some(value),
        Err(e) => cmd_res = Err(e),
    }

    // If there are currently tags set, pass through and see if this value matches any.
    if let Some(tags) = token_args.get_tag_names() {
        res_tags = Some(vec![]);
        for tag in tags {
            res_tags.as_mut().expect("").push(tag.clone());
        }
    }

    if let Some(value) = res_value {
        if let Some(tags) = res_tags {
            cmd_res = Ok((Some(tags.to_vec()), value));
        } else {
            cmd_res = Ok((None, value));
        }
    }

    cmd_res
}

/**************************************** Tests *************************************************************************/

#[cfg(test)]
#[allow(unused_imports)]
pub mod tests {
    use super::*;
    use rand::Rng;
    use std::iter::zip;

    /**************************************** Test Helpers **************************************************************/

    pub mod testconst {
        use super::*;

        pub const TEST_TAG_NAME: &str = "tagname";
        pub const TEST_TAG_NAME2: &str = "tagname2";
        pub const TEST_TAG_NAME3: &str = "tagname3";
        pub const TEST_BASE_ADDR_STR: &str = "808000";
        pub const TEST_BASE_ADDR: usize = 0x808000;
        pub const TEST_DECIMAL_VALUE_STR: &str = "50";
        pub const TEST_DECIMAL_VALUE: usize = 50;
        pub const _TEST_DECIMAL_VALUE_STR_AS_HEX: &str = "32";
        pub const TEST_WIDE_HEX_VALUE: &str = "00000A";
        pub const TEST_HEX_VALUE_STR: &str = "0A";
        pub const TEST_HEX_VALUE: usize = 0x0A;

        /// Test results for the outcome of each of the tests performed.

        /// The representation of the arguments passed as a vector of strings.

        /// Test cases which are driven purely by numeric literals, represented as string vectors.
        pub fn literal_string_args() -> Vec<Vec<&'static str>> {
            vec![
                vec!["$808000"],
                vec!["$808000", "+", "$0A"],
                vec!["$808000", "+", TEST_DECIMAL_VALUE_STR],
                vec!["+", "$0A"],
                vec!["+", TEST_DECIMAL_VALUE_STR],
                vec![TEST_DECIMAL_VALUE_STR],
                vec!["$50"],
                vec![TEST_DECIMAL_VALUE_STR, "+", "$0A"],
                vec![TEST_DECIMAL_VALUE_STR, "+", TEST_DECIMAL_VALUE_STR],
            ]
        }

        /// Test cases which are driven purely by numeric literals.
        pub fn literal_token_args() -> Vec<DebugTokenStream> {
            vec![
                // $808000
                // Hex Literal
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                ],
                // $808000+$0A
                // Hex Literal + Hex Offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                ],
                // $808000+50
                // Hex Literal + Decimal Offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                ],
                // +$0A
                // PC + Hex Offset
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                ],
                // +50
                // PC + Decimal Offset
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                ],
                // 50
                // Decimal Literal
                vec![TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR))],
                // $50
                // Hex Literal (Duplicate, to cover +50, 50, $50 and see all return diff)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                ],
                // 50+$0A
                // Decimal Literal + Hex Offset
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                ],
                // 50 + 50
                // Decimal Literal + Decimal Offset
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                ],
            ]
        }

        /// Results of test cases driven by numeric literals.
        pub fn literal_numeric_results() -> Vec<usize> {
            vec![
                0x808000, // $808000
                0x80800A, // $808000+$0A
                0x808032, // $808000+50
                0x80800A, // +$0A
                0x808032, // +50
                0x000032, // 50
                0x000050, // $50
                0x00003C, // 50+$0A
                0x000064, // 50+50
            ]
        }

        /// Test cases where the arguments are strings.
        pub fn tag_string_args() -> Vec<Vec<&'static str>> {
            let vec = vec![
                /****** Tag before value ******/
                vec![TEST_TAG_NAME, "$808000"],
                vec![TEST_TAG_NAME, TEST_DECIMAL_VALUE_STR],
                vec![TEST_TAG_NAME, "$808000", "+", "$0A"],
                vec![TEST_TAG_NAME, "$808000", "+", TEST_DECIMAL_VALUE_STR],
                vec![TEST_TAG_NAME, "+", "$0A"],
                vec![TEST_TAG_NAME, "+", TEST_DECIMAL_VALUE_STR],
                /****** Value before tag ******/
                vec!["$808000", TEST_TAG_NAME],
                vec![TEST_DECIMAL_VALUE_STR, TEST_TAG_NAME],
                vec!["$808000", "+", "$0A", TEST_TAG_NAME],
                vec!["$808000", "+", TEST_DECIMAL_VALUE_STR, TEST_TAG_NAME],
                vec!["$0A", "+", TEST_TAG_NAME],
                vec![TEST_DECIMAL_VALUE_STR, "+", TEST_TAG_NAME],
                vec!["+", "$0A", TEST_TAG_NAME],
                vec!["+", TEST_DECIMAL_VALUE_STR, TEST_TAG_NAME],
                /****** Other Combinations ******/
                vec![TEST_TAG_NAME],
                vec![TEST_TAG_NAME, "+", TEST_TAG_NAME],
                vec![TEST_TAG_NAME, "+", TEST_TAG_NAME2],
                vec![TEST_TAG_NAME, "+", TEST_TAG_NAME2, TEST_TAG_NAME3],
                vec![TEST_TAG_NAME3, TEST_TAG_NAME, "+", TEST_TAG_NAME2],
            ];
            vec
        }

        /// Test cases where a tag is represented as Value(tagname).
        pub fn token_tag_as_value() -> Vec<DebugTokenStream> {
            vec![
                /****** Tag before value ******/
                // tag $808000
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                ],
                // tag 50
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                ],
                // tag $808000 + $0A
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                ],
                // tag $808000 + 50
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                ],
                // tag +$0A
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                ],
                // tag +50
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                ],
                /****** Value before tag ******/
                // $808000 tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // 50 tag
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // $808000 + $0A tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // $808000 + 50 tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // $0A + tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // 50 + tag
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // +$0A tag
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // +50 tag
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                /****** Other tag configurations ******/
                // tag
                vec![TokenSeparator::Value(String::from(TEST_TAG_NAME))],
                // tag + tag
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                ],
                // tag + tag2
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME2)),
                ],
                // tag1 + tag2 tag3
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME2)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME3)),
                ],
                // tag3 tag1 + tag2
                vec![
                    TokenSeparator::Value(String::from(TEST_TAG_NAME3)),
                    TokenSeparator::Value(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_TAG_NAME2)),
                ],
            ]
        }

        /// Test cases where a tag is represented as Tag(tagname).
        pub fn token_tag_as_tags() -> Vec<DebugTokenStream> {
            vec![
                /******* Value After Tag *******/
                // tag $808000
                // Tag followed by Hex Literal
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                ],
                // tag 50
                // Tag followed by decimal literal
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                ],
                // tag $808000 + $0A
                // Tag, as specified by a hex literal + hex offset
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                ],
                // tag $808000 + 50
                // Tag, as specified by a hex literal + decimal offset
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                ],
                // tag + $0A
                // Tag with Hex Offset (Tag should exist prior)
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                ],
                // tag + 50
                // Tag with Decimal Offset (Tag should exist prior)
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                ],
                /******* Value before Tag *******/
                // $808000 tag
                // Hex literal followed by tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // 50 tag
                // Decimal literal followed by tag
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // $808000 + $0A tag
                // tag, as defined as Hex literal + Hex offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // $808000 + 50 tag
                // tag, as defined as Hex Literal + Decimal Offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // $0A + tag
                // Hex literal offset by tag (Tag should exist prior)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // 50 + tag
                // Decimal literal with tag offset (Tag should exist prior)
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // +$0A tag
                // tag as Hex offset from PC
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // +50 tag
                // tag as decimal offset from PC
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                /******* Other Tag Cases *******/
                // tag
                // Just a tag name
                vec![TokenSeparator::Tag(String::from(TEST_TAG_NAME))],
                // tag + tag
                // Adding a tag value to itself (should exist prior)
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // tag + tag2
                // 2 tag values (both should exist prior)
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME2)),
                ],
                // tag + tag2 tag3
                // 2 tags added = 3rd new tag
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME2)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME3)),
                ],
                // tag3 tag1 + tag2
                // 2 tags added = 3rd new tag
                vec![
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME3)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                    TokenSeparator::Offset,
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME2)),
                ],
            ]
        }

        /// Test cases where a tag is represented as the value at tagname's address.
        /// If a tag is not followed by or led by an operator, it will included as Tag("tagname") still.
        pub fn token_tag_as_deref() -> Vec<DebugTokenStream> {
            vec![
                /******* Value After Tag *******/
                // tag $808000
                // Tag followed by Hex Literal
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // tag 50
                // Tag followed by decimal literal
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // tag $808000 + $0A
                // Tag, as specified by a hex literal + hex offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // tag $808000 + 50
                // Tag, as specified by a hex literal + decimal offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // tag + $0A
                // Tag with Hex Offset (Tag should exist prior)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                ],
                // tag + 50
                // Tag with Decimal Offset (Tag should exist prior)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                ],
                /******* Value before Tag *******/
                // $808000 tag
                // Hex literal followed by tag
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // 50 tag
                // Decimal literal followed by tag
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // $808000 + $0A tag
                // tag, as defined as Hex literal + Hex offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // $808000 + 50 tag
                // tag, as defined as Hex Literal + Decimal Offset
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // $0A + tag
                // Hex literal offset by tag (Tag should exist prior)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                ],
                // 50 + tag
                // Decimal literal with tag offset (Tag should exist prior)
                vec![
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                ],
                // +$0A tag
                // tag as Hex offset from PC
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_HEX_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                // +50 tag
                // tag as decimal offset from PC
                vec![
                    TokenSeparator::Offset,
                    TokenSeparator::Value(String::from(TEST_DECIMAL_VALUE_STR)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME)),
                ],
                /******* Other Tag Cases *******/
                // tag
                // Just a tag name
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                ],
                // tag + tag
                // Adding a tag value to itself (should exist prior)
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                ],
                // tag + tag2
                // 2 tag values (both should exist prior)
                // Hex tag values will always be widened to a 6-digit hex value.
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_WIDE_HEX_VALUE)),
                ],
                // tag + tag2 tag3
                // 2 tag values (both should exist prior) equate to one new tag.
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_WIDE_HEX_VALUE)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME3)),
                ],
                // tag3 tag + tag2
                // 2 tag values (both should exist prior) equate to one new tag.
                vec![
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_BASE_ADDR_STR)),
                    TokenSeparator::Offset,
                    TokenSeparator::HexValue,
                    TokenSeparator::Value(String::from(TEST_WIDE_HEX_VALUE)),
                    TokenSeparator::Tag(String::from(TEST_TAG_NAME3)),
                ],
            ]
        }
    }

    /**************************************** Unit Test Implementations *************************************************/

    mod debugger_literal_tests {
        use super::testconst::*;
        use super::*;
        use crate::debugger::DebuggerState;

        #[test]
        fn test_collect_args() {
            let string_vectors = literal_string_args();
            let token_vectors = literal_token_args();

            for (test_input, expected_result) in zip(string_vectors, token_vectors) {
                assert_eq!(expected_result, collect_args(test_input).unwrap());
            }
        }

        #[test]
        fn test_compute_address_from_args() {
            let test_debug = DebuggerState::new();
            let test_vm = VirtualMachine::new();
            let numeric_result_vector = literal_numeric_results();
            let token_vectors = literal_token_args();

            for (test_input, expected_result) in zip(token_vectors, numeric_result_vector) {
                println!("Test input is {:?}", test_input);
                let test_result =
                    compute_address_from_args(&test_input, &test_debug.breakpoint_state, &test_vm)
                        .unwrap();
                println!(
                    "Expected Result was {:#08X} Test Result was {:#08X}",
                    expected_result, test_result
                );
                assert_eq!(expected_result, test_result);
            }
        }

        #[test]
        fn test_apply_modifiers() {
            let test_debug = DebuggerState::new();
            let test_vm = VirtualMachine::new();
            let token_vectors = literal_token_args();
            let numeric_result_vector = literal_numeric_results();

            for (test_input, expected_result) in zip(token_vectors, numeric_result_vector) {
                let test_result =
                    compute_address_from_args(&test_input, &test_debug.breakpoint_state, &test_vm)
                        .unwrap();
                println!(
                    "Expected Result was {:#08X} Test Result was {:#08X}",
                    expected_result, test_result
                );
                assert_eq!(expected_result, test_result);
            }
        }
    }

    mod debugger_tag_tests {
        use super::testconst::*;
        use super::*;
        use crate::debugger::DebuggerState;

        #[test]
        fn test_collect_args() {
            let string_vectors: Vec<Vec<&str>> = tag_string_args();
            let token_vectors = token_tag_as_value();
            for (test_input, expected_result) in zip(string_vectors, token_vectors) {
                let test_result = collect_args(test_input).unwrap();
                assert_eq!(expected_result, test_result);
            }
        }

        #[test]
        fn test_collect_tags() {
            // Get the table of test cases where a tag is represented as TokenSeparator::Value(tagname).
            let test_token_vectors = token_tag_as_value();

            // Get the table of test cases where a tag is represented as a TokenSeparator::Tag(tagname).
            let expected_token_vectors = token_tag_as_tags();

            for (test_input, expected_result) in zip(test_token_vectors, expected_token_vectors) {
                let test_result = collect_tags(test_input);
                assert_eq!(expected_result, test_result);
            }
        }

        #[test]
        fn test_deref_tags() {
            let mut test_table = ParserData::new();
            test_table.insert_tag(TEST_TAG_NAME, TEST_BASE_ADDR);
            test_table.insert_tag(TEST_TAG_NAME2, TEST_HEX_VALUE);
            let test_tag_tokens = token_tag_as_tags();
            let test_deref_tokens = token_tag_as_deref();

            for (test_input, expected_result) in zip(test_tag_tokens, test_deref_tokens) {
                // println!("Test input is {:?}", test_input);
                let test_result = deref_tags(test_input, &test_table).unwrap();

                // println!("Test result was {:?}", test_result);
                assert_eq!(expected_result, test_result);
            }
        }

        #[test]
        fn test_create_new_tag() {
            let mut debug = DebuggerState::new();
            let vm = VirtualMachine::new();

            let test_tag_tokens = token_tag_as_tags();

            let numeric_results: Vec<Option<(&str, usize)>> = vec![
                Some((TEST_TAG_NAME, TEST_BASE_ADDR)),     // tag $808000
                Some((TEST_TAG_NAME, TEST_DECIMAL_VALUE)), // tag 50
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_HEX_VALUE))), // tag $808000 + $0A
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_DECIMAL_VALUE))), // tag $808000 + 50
                None,                                      // tag +$0A
                None,                                      // tag +50
                /* Value before tag */
                Some((TEST_TAG_NAME, TEST_BASE_ADDR)), // $808000 tag
                Some((TEST_TAG_NAME, TEST_DECIMAL_VALUE)), // 50 tag
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_HEX_VALUE))), // $808000 + $0A tag
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_DECIMAL_VALUE))), // $808000 + 50 tag
                None,                                  // will fail  // $0A + tag
                None,                                  // will fail  // 50 + tag
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_HEX_VALUE))), // +$0A tag
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_DECIMAL_VALUE))), // +50 tag
                /* Other */
                Some((TEST_TAG_NAME, TEST_BASE_ADDR)), // tag
                None,                                  // will fail, // tag + tag
                None,                                  // will fail, // tag + tag2
                None,                                  // will fail, // tag + tag2 tag3
                None,                                  // will fail  // tag3 tag + tag2
            ];

            for (test_input, expected_result) in zip(test_tag_tokens, numeric_results) {
                // println!(
                //     "\nTest input is {:?}\nExpected Result is {:?}",
                //     test_input, expected_result
                // );

                if let Some((expected_name, expected_value)) = expected_result {
                    let tag_result =
                        create_new_tag(&test_input, &debug.breakpoint_state, &vm).unwrap();
                    // Check the results from generating the tag.
                    assert_eq!(expected_name, tag_result.0);
                    assert_eq!(expected_value, tag_result.1);

                    // Create a new debugger instance, because deletion is private to breakpoints
                    debug = DebuggerState::new();
                } else {
                    assert!(create_new_tag(&test_input, &debug.breakpoint_state, &vm).is_err());
                }
            }
        }

        #[test]
        fn test_create_new_tag_from_existing() {
            let mut test_table;
            let vm = VirtualMachine::new();
            let test_tag_tokens = token_tag_as_tags();
            let numeric_results: Vec<Option<(&str, usize)>> = vec![
                Some((TEST_TAG_NAME, TEST_BASE_ADDR)),     // tag $808000
                Some((TEST_TAG_NAME, TEST_DECIMAL_VALUE)), // tag 50
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_HEX_VALUE))), // tag $808000 + $0A
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_DECIMAL_VALUE))), // tag $808000 + 50
                None,                                      // tag +$0A
                None,                                      // tag +50
                /* Value before tag */
                Some((TEST_TAG_NAME, TEST_BASE_ADDR)), // $808000 tag
                Some((TEST_TAG_NAME, TEST_DECIMAL_VALUE)), // 50 tag
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_HEX_VALUE))), // $808000 + $0A tag
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_DECIMAL_VALUE))), // $808000 + 50 tag
                None,                                  // $0A + tag
                None,                                  // 50 + tag
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_HEX_VALUE))), // +$0A tag
                Some((TEST_TAG_NAME, (TEST_BASE_ADDR + TEST_DECIMAL_VALUE))), // +50 tag
                /* Other */
                None, // FIXME: This use case is not common, but is unaccounted for.
                None, // tag + tag
                None, // tag + tag2
                Some((TEST_TAG_NAME3, (TEST_BASE_ADDR + TEST_HEX_VALUE))), // tag + tag2 tag3
                Some((TEST_TAG_NAME3, (TEST_BASE_ADDR + TEST_HEX_VALUE))), // tag3 tag + tag2
            ];

            for (test_input, expected_result) in zip(test_tag_tokens, numeric_results) {
                test_table = ParserData::new();
                test_table.insert_tag(TEST_TAG_NAME, TEST_BASE_ADDR);
                test_table.insert_tag(TEST_TAG_NAME2, TEST_HEX_VALUE);

                println!(
                    "\nTest input is {:?}\nExpected Result is {:?}",
                    test_input, expected_result
                );

                if let Some((expected_tagname, expected_value)) = expected_result {
                    let tag_result = create_new_tag(&test_input, &test_table, &vm).unwrap();
                    println!("Result was: {:?}", tag_result);
                    // Check that the outcome is correct.
                    assert_eq!(expected_tagname, tag_result.0);
                    assert_eq!(expected_value, tag_result.1);
                } else {
                    println!("\nTesting for error!");
                    println!(
                        "Result from create_new was: {:?}",
                        create_new_tag(&test_input, &test_table, &vm)
                    );
                    assert!(create_new_tag(&test_input, &test_table, &vm).is_err());
                }
            }
        }

        #[test]
        fn test_str_to_args() {
            let string_vectors: Vec<Vec<&str>> = tag_string_args();
            let token_tag_vectors = token_tag_as_tags();

            for (test_input, expected_output) in zip(string_vectors, token_tag_vectors) {
                assert_eq!(expected_output, str_to_args(&test_input).unwrap());
            }
        }

        #[test]
        fn test_str_to_values() {
            let string_vectors = tag_string_args();
            let value_result: Vec<Option<(Option<Vec<String>>, usize)>> = vec![
                /****** Tag before value ******/
                None, //vec![TEST_TAG_NAME, "$808000"],
                None, //vec![TEST_TAG_NAME, TEST_DECIMAL_VALUE_STR],
                None, //vec![TEST_TAG_NAME, "$808000", "+", "$0A"],
                None, //vec![TEST_TAG_NAME, "$808000", "+", TEST_DECIMAL_VALUE_STR],
                Some((Some(vec![TEST_TAG_NAME.to_string()]), 0x80800A)), //vec![TEST_TAG_NAME, "+", "$0A"],
                Some((Some(vec![TEST_TAG_NAME.to_string()]), 0x808032)), //vec![TEST_TAG_NAME, "+", TEST_DECIMAL_VALUE_STR],
                /****** Value before tag ******/
                None, //vec!["$808000", TEST_TAG_NAME],
                None, //vec![TEST_DECIMAL_VALUE_STR, TEST_TAG_NAME],
                None, //vec!["$808000", "+", "$0A", TEST_TAG_NAME],
                None, //vec!["$808000", "+", TEST_DECIMAL_VALUE_STR, TEST_TAG_NAME],
                Some((Some(vec![TEST_TAG_NAME.to_string()]), 0x80800A)), //vec!["$0A", "+", TEST_TAG_NAME],
                Some((Some(vec![TEST_TAG_NAME.to_string()]), 0x808032)), //vec![TEST_DECIMAL_VALUE_STR, "+", TEST_TAG_NAME],
                None, //vec!["+", "$0A", TEST_TAG_NAME],
                None, //vec!["+", TEST_DECIMAL_VALUE_STR, TEST_TAG_NAME],
                /****** Other Combinations ******/
                Some((Some(vec![TEST_TAG_NAME.to_string()]), 0x808000)), //vec![TEST_TAG_NAME],
                None, //vec![TEST_TAG_NAME, "+", TEST_TAG_NAME],
                Some((
                    Some(vec![TEST_TAG_NAME.to_string(), TEST_TAG_NAME2.to_string()]),
                    0x80800A,
                )), //vec![TEST_TAG_NAME, "+", TEST_TAG_NAME2],
                None, //vec![TEST_TAG_NAME, "+", TEST_TAG_NAME2, TEST_TAG_NAME3],
                None, //vec![TEST_TAG_NAME3, TEST_TAG_NAME, "+", TEST_TAG_NAME2],
                      //(Some(vec![TEST_TAG_NAME3.to_string()]), 0x80800A),
            ];
            let mut test_debug = DebuggerState::new();
            let test_vm = VirtualMachine::new();

            test_debug
                .breakpoint_state
                .insert_tag(TEST_TAG_NAME, TEST_BASE_ADDR);
            test_debug
                .breakpoint_state
                .insert_tag(TEST_TAG_NAME2, TEST_HEX_VALUE);
            test_debug
                .breakpoint_state
                .insert_tag(TEST_TAG_NAME3, TEST_BASE_ADDR + TEST_HEX_VALUE);

            for (test_input, expected_result) in zip(string_vectors, value_result) {
                if let Some(result) = expected_result {
                    assert_eq!(
                        result,
                        str_to_values(&test_input, &test_debug.breakpoint_state, &test_vm).unwrap()
                    )
                } else {
                    assert!(
                        str_to_values(&test_input, &test_debug.breakpoint_state, &test_vm).is_err()
                    );
                }
            }
        }

        #[test]
        fn test_compute_address_from_args() {
            let token_vectors = token_tag_as_deref();
            let numeric_results: Vec<Option<usize>> = vec![
                None,                                      // tag $808000
                None,                                      // tag 50
                None,                                      // tag $808000 + $0A
                None,                                      // tag $808000 + 50
                Some(TEST_BASE_ADDR + TEST_HEX_VALUE),     // tag +$0A
                Some(TEST_BASE_ADDR + TEST_DECIMAL_VALUE), // tag +50
                /* Value before tag */
                None,                                      // $808000 tag
                None,                                      // 50 tag
                None,                                      // $808000 + $0A tag
                None,                                      // $808000 + 50 tag
                Some(TEST_BASE_ADDR + TEST_HEX_VALUE),     // $0A + tag
                Some(TEST_BASE_ADDR + TEST_DECIMAL_VALUE), // 50 + tag
                None,                                      // will fail  // +$0A tag
                None,                                      // will fail  // +50 tag
                /* Other */
                Some(TEST_BASE_ADDR),                  // tag
                None,                                  // tag + tag
                Some(TEST_BASE_ADDR + TEST_HEX_VALUE), // tag + tag2
                None,                                  // will fail, // tag + tag2 tag3
                None,                                  // will fail  // tag3 tag + tag2
            ];
            let mut test_table;
            let test_vm = VirtualMachine::new();

            for (test_input, expected_result) in zip(token_vectors, numeric_results) {
                test_table = ParserData::new();
                test_table.insert_tag(TEST_TAG_NAME, TEST_BASE_ADDR);
                test_table.insert_tag(TEST_TAG_NAME2, TEST_HEX_VALUE);

                println!("Test Case is: {:?}", test_input);
                println!(
                    "Output was: {:?}",
                    compute_address_from_args(&test_input, &test_table, &test_vm)
                );
                if let Some(result) = expected_result {
                    assert_eq!(
                        result,
                        compute_address_from_args(&test_input, &test_table, &test_vm).unwrap()
                    );
                } else {
                    assert!(compute_address_from_args(&test_input, &test_table, &test_vm).is_err());
                }
            }
        }

        // #[test]
        // fn test_apply_modifiers() {}
    }
}
